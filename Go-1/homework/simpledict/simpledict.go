package main

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"log"
	"net/http"
	"os"
)

type DictRequest struct {
	TransType string `json:"trans_type"`
	Source    string `json:"source"`
	UserID    string `json:"user_id"`
}

type AutoGenerated struct {
	Rc   int `json:"rc"`
	Wiki struct {
	} `json:"wiki"`
	Dictionary struct {
		Prons struct {
			EnUs string `json:"en-us"`
			En   string `json:"en"`
		} `json:"prons"`
		Explanations []string      `json:"explanations"`
		Synonym      []string      `json:"synonym"`
		Antonym      []string      `json:"antonym"`
		WqxExample   [][]string    `json:"wqx_example"`
		Entry        string        `json:"entry"`
		Type         string        `json:"type"`
		Related      []interface{} `json:"related"`
		Source       string        `json:"source"`
	} `json:"dictionary"`
}

type BaiDuDiction struct {
	Edict struct {
		Item []struct {
			TrGroup []struct {
				Tr          []string `json:"tr"`
				Example     []string `json:"example"`
				SimilarWord []string `json:"similar_word"`
			} `json:"tr_group"`
			Pos string `json:"pos"`
		} `json:"item"`
		Word string `json:"word"`
	} `json:"edict"`
	Collins struct {
		Entry []struct {
			EntryID string `json:"entry_id"`
			Type    string `json:"type"`
			Value   []struct {
				MeanType []struct {
					InfoType string `json:"info_type"`
					InfoID   string `json:"info_id"`
					Example  []struct {
						ExampleID string `json:"example_id"`
						TtsSize   string `json:"tts_size"`
						Tran      string `json:"tran"`
						Ex        string `json:"ex"`
						TtsMp3    string `json:"tts_mp3"`
					} `json:"example"`
				} `json:"mean_type"`
				Gramarinfo []interface{} `json:"gramarinfo"`
				Tran       string        `json:"tran"`
				Def        string        `json:"def"`
				MeanID     string        `json:"mean_id"`
				Posp       []struct {
					Label string `json:"label"`
				} `json:"posp"`
			} `json:"value"`
		} `json:"entry"`
		WordName      string `json:"word_name"`
		Frequence     string `json:"frequence"`
		WordEmphasize string `json:"word_emphasize"`
		WordID        string `json:"word_id"`
	} `json:"collins"`
	From        string `json:"from"`
	SimpleMeans struct {
		WordName  string   `json:"word_name"`
		From      string   `json:"from"`
		WordMeans []string `json:"word_means"`
		Exchange  struct {
			WordEst []string `json:"word_est"`
			WordEr  []string `json:"word_er"`
		} `json:"exchange"`
		Tags struct {
			Core  []string `json:"core"`
			Other []string `json:"other"`
		} `json:"tags"`
		Symbols []struct {
			PhEn  string `json:"ph_en"`
			PhAm  string `json:"ph_am"`
			Parts []struct {
				Part  string   `json:"part"`
				Means []string `json:"means"`
			} `json:"parts"`
			PhOther string `json:"ph_other"`
		} `json:"symbols"`
	} `json:"simple_means"`
	Lang   string `json:"lang"`
	Oxford struct {
		Entry []struct {
			Tag  string `json:"tag"`
			Name string `json:"name"`
			Data []struct {
				Tag  string `json:"tag"`
				Data []struct {
					Tag   string `json:"tag"`
					P     string `json:"p"`
					PText string `json:"p_text"`
				} `json:"data"`
			} `json:"data"`
		} `json:"entry"`
		Unbox []struct {
			Tag  string `json:"tag"`
			Type string `json:"type"`
			Name string `json:"name"`
			Data []struct {
				Tag     string `json:"tag"`
				Text    string `json:"text,omitempty"`
				Words   string `json:"words,omitempty"`
				Outdent string `json:"outdent,omitempty"`
				Data    []struct {
					Tag    string `json:"tag"`
					EnText string `json:"enText"`
					ChText string `json:"chText"`
				} `json:"data,omitempty"`
			} `json:"data"`
		} `json:"unbox"`
	} `json:"oxford"`
	Sanyms []struct {
		Tit  string `json:"tit"`
		Data []struct {
			P string   `json:"p"`
			D []string `json:"d"`
		} `json:"data"`
		Type string `json:"type"`
	} `json:"sanyms"`
	Usecase struct {
		Idiom []struct {
			P    string `json:"p"`
			Tag  string `json:"tag"`
			Data []struct {
				Tag  string `json:"tag"`
				Data []struct {
					EnText string `json:"enText"`
					Tag    string `json:"tag"`
					ChText string `json:"chText"`
					Before []struct {
						Tag  string `json:"tag"`
						Data []struct {
							EnText string `json:"enText"`
							Tag    string `json:"tag"`
							ChText string `json:"chText"`
						} `json:"data"`
					} `json:"before,omitempty"`
				} `json:"data"`
			} `json:"data"`
		} `json:"idiom"`
	} `json:"usecase"`
	Synonym []struct {
		Synonyms []struct {
			Tips string `json:"tips"`
			Bx   string `json:"bx"`
			Syn  struct {
				P    string   `json:"p"`
				Word string   `json:"word"`
				D    []string `json:"d"`
			} `json:"syn"`
			Ex []struct {
				EnText string `json:"enText"`
				ChText string `json:"chText"`
			} `json:"ex"`
		} `json:"synonyms"`
		Guide string   `json:"guide"`
		Words []string `json:"words"`
	} `json:"synonym"`
	BaiduPhrase []struct {
		Tit   []string `json:"tit"`
		Trans []string `json:"trans"`
	} `json:"baidu_phrase"`
	QueryExplainVideo struct {
		ID           int    `json:"id"`
		UserID       string `json:"user_id"`
		UserName     string `json:"user_name"`
		UserPic      string `json:"user_pic"`
		Query        string `json:"query"`
		Direction    string `json:"direction"`
		Type         string `json:"type"`
		Tag          string `json:"tag"`
		Detail       string `json:"detail"`
		Status       string `json:"status"`
		SearchType   string `json:"search_type"`
		FeedURL      string `json:"feed_url"`
		Likes        string `json:"likes"`
		Plays        string `json:"plays"`
		CreatedAt    string `json:"created_at"`
		UpdatedAt    string `json:"updated_at"`
		DuplicateID  string `json:"duplicate_id"`
		RejectReason string `json:"reject_reason"`
		CoverURL     string `json:"coverUrl"`
		VideoURL     string `json:"videoUrl"`
		ThumbURL     string `json:"thumbUrl"`
		VideoTime    string `json:"videoTime"`
		VideoType    string `json:"videoType"`
	} `json:"queryExplainVideo"`
}

// func baiduQuery(word string) {

// }

func query(word string) {
	client := &http.Client{}
	request := DictRequest{TransType: "en2zh", Source: word}
	buf, err := json.Marshal(request)
	if err != nil {
		log.Fatal(err)
	}
	var data = bytes.NewReader(buf)
	req, err := http.NewRequest("POST", "https://api.interpreter.caiyunai.com/v1/dict", data)
	if err != nil {
		log.Fatal(err)
	}
	req.Header.Set("Accept", "application/json, text/plain, */*")
	req.Header.Set("Accept-Language", "zh-CN,zh;q=0.9")
	req.Header.Set("Connection", "keep-alive")
	req.Header.Set("Content-Type", "application/json;charset=UTF-8")
	req.Header.Set("Origin", "https://fanyi.caiyunapp.com")
	req.Header.Set("Referer", "https://fanyi.caiyunapp.com/")
	req.Header.Set("Sec-Fetch-Dest", "empty")
	req.Header.Set("Sec-Fetch-Mode", "cors")
	req.Header.Set("Sec-Fetch-Site", "cross-site")
	req.Header.Set("User-Agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/101.0.4951.54 Safari/537.36")
	req.Header.Set("X-Authorization", "token:qgemv4jr1y38jyq6vhvi")
	req.Header.Set("app-name", "xy")
	req.Header.Set("os-type", "web")
	req.Header.Set("sec-ch-ua", `" Not A;Brand";v="99", "Chromium";v="101", "Google Chrome";v="101"`)
	req.Header.Set("sec-ch-ua-mobile", "?0")
	req.Header.Set("sec-ch-ua-platform", `"Windows"`)
	resp, err := client.Do(req)
	if err != nil {
		log.Fatal(err)
	}
	defer resp.Body.Close()
	bodyText, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		log.Fatal(err)
	}
	var autoGenerated AutoGenerated
	err = json.Unmarshal(bodyText, &autoGenerated)
	if err != nil {
		log.Fatal(err)
	}
	fmt.Println(word, "UK:", autoGenerated.Dictionary.Prons.En, "US:", autoGenerated.Dictionary.Prons.EnUs)
	for _, item := range autoGenerated.Dictionary.Explanations {
		fmt.Println(item)
	}
	//fmt.Printf("%s\n", bodyText)
}

func main() {
	if len(os.Args) != 2 {
		fmt.Fprintf(os.Stderr, `usage: simpleDict WORD
example: simpleDict hello
		`)
		os.Exit(1)
	}
	word := os.Args[1]
	query(word)
}
